## Documentation {transition="none"}

![](www/pillars-3.png)

::: {.notes}

- In the pillar of Documentation, empathy means providing clear guides and roadmaps for collaborators, including your future self

:::

## Documentation {transition="none"}

![](www/dont-forget.png)

::: {.notes}

- Here's my public service announcement: Please treat documentation as a first class citizen in your software development practices.
- Years ago I heard someone say that software shouldn't be a bunch of code with a little bit of documentation -- the ratio should actually be opposite -- in an ideal world we should have a lot of documentation with a little bit of code.
- I'm going to talk about documentation in the contexts of (a) function documentation and (b) git-based documentation such as Issues and Pull Requests

:::

## Documentation: Function Documentation Syntax {transition="none-out"}

::: {.columns}
::: {.column}

```{.r}
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python}
def round_up(x, dig):
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- Consider this simple function that rounds a number to a certain number of digits and forces it to round up.
- The syntax is strikingly similar across both R and Python, but the point here is going to be around the documentation of the function.

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- In R, we have Roxygen as the prevailing framework for function documentation
- In Python, we have a couple of options and a little bit more flexibility -- the prevailing two options these days seem to be either Google or Scipy's approach to docstrings
    + Within our team, we tend to go with the Scipy approach for no particular reason other than I think it's slightly easier to read and Scipy itself is a little more data-science focused
- So let's compare the Roxygen framework to the Python Scipy framework

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="1-2"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="3-4"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- You can kind of just stick your high-level function description at the beginning of your documentation

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="4-8"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="6-13"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- Function arguments are defined in "param" tags in R and under a "Parameter" section in Python
- Python tends to traditionally be more explicit about supplying argument *types* next to the parameter, and while not required by Roxygen, we've tried to adopt that in R as well

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="10"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="15-18"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- The output of the function is documented in a "Returns" tag or section in both languages

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="12-14"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="20-23"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- And examples are always critical and similarly structured in both cases
- When we leverage these parallels in how we document our functions across the two languages, it's yet another relatively simple way that we make it easier to cross the language aisle and work together

:::

## Documentation: Issues & PRs

<br>

![](www/git-sdlc.png)

::: {.notes}

- Jumping now to our approach to what I'll call GitHub < air quotes > "documentation" via isues and pull requests
- If you're on a data science team, there are probably a few different approaches to how you could structure your collaborative workflows
- I'm going to show our current approach, which I believe is not only ours, but a similar workflow to what's in place at other organizations we've seen, including Posit
- First, a user or developer identifies a bug in the software or comes up with an enhancement that we've agreed to implement, and they write this up in a detailed "issue"
- Once that issue has been created, when we're ready to actually work on making the required code changes, we first create a new git *branch* in the repository specifically for the purpose of addressing that "issue"
- Then they go off and write or modify the code that fixes the bug or adds the enhancement
- And once the developer feels like the updated code is in a good spot, they can write up a Pull Request (or "PR", for short) that details how they addressed the issue, what changed, and more

:::

## Documentation: Issues {.smaller}

<br>

::: {.callout-note icon="false"}

## Anatomy of a Good Issue

### Overview

*An overview of the issue or proposed enhancement, including rationale.*

<br>

### Reproducible Example

*Some code that someone else can run to reproduce the issue or show the current shortfall that the proposed enhancement will overcome.*

<br>

### Potential Solution(s)

*Discussion (possibly including code) regarding possible solution(s).*

:::

::: {.notes}

- Let's focus first on Issues
- A good issue is composed of 3 parts:
    + First, an overview of the bug you're encountering or the enhancement you're proposing, including the rationale for why we feel a change to the code is necessary
    + Second, a reprex: a.k.a some code that someone else can run to reproduce the issue or show the current shortfall that the proposed enhancement will overcome
    + Lastly, a discussion (which may or may not include code) regarding possible solution(s)

:::

## Documentation: Issues

{{< video www/good-issue.mp4 >}}

::: {.notes}

- I thought I'd show an example "real-world" GitHub Issue we've authored that contains this structure: an overview, a reproducible example, and a possible solution that's being provided

:::

## Documentation: Pull Requests {.smaller}

<br>

::: {.callout-note icon="false"}

## Anatomy of a Good Pull Request

### Overview

*The purpose of the pull request and the associated Issue(s) it addresses.*

<br>

### Details

*The technical aspects of how the Issue was addressed in code, as well as any design decisions that were made along the way and/or hurdles that were overcome.*

<br>

### How to Test

*Provide instructions and code that the reviewer can run to see the impact of your changes.*

:::

::: {.notes}

- On the Pull Requests side, it's very similar
- A good pull request is also composed of 3 parts:
    + First, the purpose of the pull request and the associated Issue -- or Issues -- that it addresses
    + Second, a more "in the weeds" section that details the technical aspects of how the Issue was addressed in code, as well as any design decisions that were made along the way, or any hurdles that were overcome
    + Lastly, instructions and code that the reviewer can run to see the impact of your changes

:::

## Documentation: Pull Requests

{{< video www/good-pr.mp4 height="500" >}}

::: {.notes}

- I'm going to pick on Ivan on our team for a minute here, because he does an awesome job at this
    + Here's an example of a GitHub Pull Request he authored containing those three components I just mentioned: an overview, a "details" section, a "test" section, and even a "discussion" section that provides some additional context to the reviewer
- In the interest of time, I won't show more examples beyond Issues and Pull Requests, but we also take a standardized approach to our READMEs in each repository as well, making sure to document -- at a minimum -- (a) the purpose of the repository and project background, (b) prerequisites or dependencies you'll need to run the code, and (c) how to use the software.

:::