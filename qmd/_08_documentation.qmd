## Documentation {transition="none"}

![](www/pillars-3.png)

::: {.notes}

- In the pillar of Documentation, empathy means providing clear guides and roadmaps for collaborators, including your future self

:::

## Documentation {transition="none"}

![](www/dont-forget.png)

::: {.notes}

- Here's my public service announcement: Please treat documentation as a first class citizen in your software development practices.
- Years ago I heard someone say that software shouldn't be a bunch of code with a little bit of documentation -- the ratio should actually be opposite -- in an ideal world we should have a lot of documentation with a little bit of code.
- I'm going to talk about documentation in the contexts of (a) function documentation and (b) git-based documentation such as Issues and Pull Requests

:::

## Documentation: Function Documentation Syntax {transition="none-out"}

::: {.columns}
::: {.column}

```{.r}
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python}
def round_up(x, dig):
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- Consider this simple function that rounds a number to a certain number of digits and forces it to round up.
- The syntax is strikingly similar across both R and Python, but the point here is going to be around the documentation of the function.

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- In R, we have Roxygen as the prevailing framework for function documentation
- In Python, we have a couple of options and a little bit more flexibility -- the prevailing frameworks these days seem to be Google's docstring approach and Scipy's docstring approach
    + We tend to go with the Scipy approach for no particular reason other than I think it's slightly easier to read and Scipy itself is a little more data-science focused
- So let's compare the Roxygen framework to the Python Scipy framework

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="1-2"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="3-4"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- You can kind of just stick your high-level function description at the beginning of your documentation

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="4-8"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="6-13"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- Function arguments are defined in "param" tags in R and under a "Parameter" section in Python
- Python tends to traditionally be more explicit about supplying argument *types* next to the parameter, and while not required by Roxygen, we've tried to adopt that in R as well

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="10"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="15-18"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- The output of the function is documented in a "Returns" tag or section in both languages

:::

## Documentation: Function Documentation Syntax {transition="none"}

::: {.columns}
::: {.column}

```{.r code-line-numbers="12-14"}
#' Round a number *up* to a
#' certain number of digits.
#'
#' @param x (double) The value
#'   to be rounded.
#' @param dig (int) The
#'   number of digits to round
#'   to.
#'
#' @return The rounded number.
#'
#' @examples
#' # This returns `2.15`
#' round_up(2.141, 2)
round_up <- function(x, dig) {
    f <- 10 ** dig
    out <- ceiling(x * f) / f
    return(out)
}
```

:::

::: {.column}

```{.python code-line-numbers="20-23"}
def round_up(x, dig):
    """
    Round a number *up* to a
    certain number of digits.

    Parameters
    ----------
    x : float
        The value to be
        rounded.
    dig : int
        The number of digits to
        round to.

    Returns
    -------
    float
        The rounded number.

    Examples
    --------
    >>> round_up(2.141, 2)
    2.15
    """
    f = 10 ** dig
    out = np.ceil(x * f) / f
    return out
```

:::
:::

::: {.notes}

- And examples are always critical and similarly structured in both examples

:::

## Documentation: Issues & PRs

<br>

![](www/git-sdlc.png)

::: {.notes}

- Let's move on to the last pillar of an effective multilingual data science team: Documentation
- If you're on a data science team, there are probably a few different approaches to how you could structure collaborative workflows when working on projects together.
- I'm going to show our current approach, which I believe is not only ours, but a similar workflow to what's in place at other organizations we've seen, including Posit
- First, a user or developer identifies a bug in the software or comes up with an enhancement that we've agreed to implement
- They write up their idea in a detailed "issue"
- The first step in working on that is to create a new git *branch* in the repository specifically for the purpose of addressing that "issue"
- Then they go off and write or modify the code that fixes the bug or adds the enhancement
- And once they feel like the updated code is in a good spot, they can write up a Pull Request (or "PR") that details how they addressed the issue, what changed, and more

:::

## Documentation: Issues {.smaller}

<br>

::: {.callout-note icon="false"}

## Anatomy of a Good Issue

### Overview

*An overview of the issue or proposed enhancement, including rationale.*

<br>

### Reproducible Example

*Some code that someone else can run to reproduce the issue or show the current shortfall that the proposed enhancement will overcome.*

<br>

### Potential Solution(s)

*Discussion (possibly including code) regarding possible solution(s).*

:::

## Documentation: Issues

{{< video www/good-issue.mp4 >}}

## Documentation: Pull Requests {.smaller}

<br>

::: {.callout-note icon="false"}

## Anatomy of a Good Pull Request

### Overview

*The purpose of the pull request and the associated Issue(s) it addresses.*

<br>

### Details

*The technical aspects of how the Issue was addressed in code, as well as any design decisions that were made along the way and/or hurdles that were overcome.*

<br>

### How to Test

*Provide instructions and code that the reviewer can run to see the impact of your changes.*

:::

## Documentation: Pull Requests

{{< video www/good-pr.mp4 height="500" >}}

::: {.notes}

- In the interest of time, I won't show more examples beyond Issues and Pull Requests, but we also take a standardized approach to our READMEs in each repository as well, making sure to document -- at a minimum -- (a) the purpose of the repository and project background, (b) prerequisites or dependencies you'll need to run the code, and (c) how to use the software.

:::